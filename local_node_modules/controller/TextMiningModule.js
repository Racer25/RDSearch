var Natural = require('natural');

var giveSymptomsWithOccurrence = function(dictionary, text, callback)
{
    ///////////////////////
    //TEXT PRE-PROCESSING//
    ///////////////////////

    //To Lower case
    text = text.toLowerCase();

    //We tokenize our string
    var tokenizer = new Natural.WordTokenizer();
    var tokensText = tokenizer.tokenize(text);

    //Deleting stop words (from https://github.com/6/stopwords-json)
    var stopWords = require("../../download/stopWords_en.json");
    tokensText = tokensText.filter(function(currentValue, index, arr) {return stopWords.indexOf(currentValue) === -1;});

    /*
    //Stemming
    for(var i = 0; i < tokensText.length; i++)
    {
        tokensText[i] = Natural.PorterStemmer.stem(tokensText[i]);
    }
    */

    /////////////////////////////
    //DICTIONARY PRE-PROCESSING//
    /////////////////////////////
    var tokensDictionary =[];
    for(var i = 0; i < dictionary.length; i++)
    {
        var tempTokens =tokenizer.tokenize(dictionary[i]+"");
        for(var j = 0; j < tempTokens.length; j++)
        {
            //To Lower case
            tempTokens[j] = tempTokens[j].toLowerCase();
            tokensDictionary.push({token: tempTokens[j], indexSymptomRelated:i});
        }
    }

    //Deleting stop words (from https://github.com/6/stopwords-json)
    tokensDictionary = tokensDictionary.filter(function(currentValue, index, arr) {return stopWords.indexOf(currentValue.token) === -1;});

    /*
    //Stemming
    for(var i = 0; i < tokensDictionary.length; i++)
    {
        tokensDictionary[i].token = Natural.PorterStemmer.stem(tokensDictionary[i].token+"");
    }
    */

    /////////////////////////////////
    //COMPUTING WEIGHT FOR SYMPTOMS//
    /////////////////////////////////
    var symptomsWithOccurence = [];

    for(var i = 0; i < tokensText.length; i++)
    {
        for(var j = 0; j < tokensDictionary.length; j++)
        {
            if(tokensText[i] === tokensDictionary[j].token)
            //if(Natural.LevenshteinDistance(tokensText[i], tokensDictionary[j].token) < 2)
            {
                //Increment counter or Add to array
                var index= symptomsWithOccurence.map(function(value, index, arr){return value.name}).indexOf(tokensText[i]);
                if(index !== -1 )
                {
                    symptomsWithOccurence[index].size++;
                }
                else
                {
                    symptomsWithOccurence.push({name: dictionary[tokensDictionary[j].indexSymptomRelated], size: 1});
                }
            }

        }
    }

    callback(symptomsWithOccurence);
};

var giveSymptomsWithOccurrenceWithLingPipe = function(publications, callback)
{
    //console.log(__base+"jars/lingPipe.jar");
    var lingPipeProcess = require('child_process').spawn('java', ['-jar', __base+"jars/lingPipe.jar",'anArgument']);

    var symptomsWithSize=[];

    //console.log("Length: "+publications.length);

    //Work in progress (called several times, for each symptoms detected)
    lingPipeProcess.stdout.on('data', function(data)
    {
        //console.log("Nombre de symptomes identifiés: "+ symptomsWithSize.length);

        var symptom = data.toString();

        //Check if symptom already here and if true, give index i
        var i=0;
        var symptomAlreadyUsed=false;
        while(!symptomAlreadyUsed && i < symptomsWithSize.length)
        {
            if(symptomsWithSize[i].name === symptom)
            {
                symptomAlreadyUsed = true;
            }
            else
            {
                i++;
            }
        }

        //Increment counter or Add to array
        if(symptomAlreadyUsed)
        {
            symptomsWithSize[i].size++;
        }
        else
        {
            symptomsWithSize.push({name: symptom, size: 1});
        }
    });

    lingPipeProcess.stderr.on("data", function (data) {
        console.log("ERREUR, message reçu: " + data.toString());
    });

    //When it's finished
    lingPipeProcess.on('exit', function() {
        callback(symptomsWithSize);
        console.log("Fin de la recherche de symptomes");
    });

    //We send publications JSON via STDIN
    //console.log(JSON.stringify(publications));
    lingPipeProcess.stdin.write(JSON.stringify(publications)+"\n");
};

exports.giveSymptomsWithOccurrence=giveSymptomsWithOccurrence;
exports.giveSymptomsWithOccurrenceWithLingPipe=giveSymptomsWithOccurrenceWithLingPipe;