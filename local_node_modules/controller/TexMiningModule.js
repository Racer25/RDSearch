var Natural = require('natural');

var giveSymptomsWithOccurrence = function(dictionary, text, callback)
{
    ///////////////////////
    //TEXT PRE-PROCESSING//
    ///////////////////////

    //To Lower case
    text = text.toLowerCase();

    //We tokenize our string
    var tokenizer = new Natural.WordTokenizer();
    var tokens = tokenizer.tokenize(text);

    //Deleting stop words (from https://github.com/6/stopwords-json)
    var stopWords = require("../../download/stopWords_en.json");
    tokens = tokens.filter(function(currentValue, index, arr) {return stopWords.indexOf(currentValue) == -1;});

    //Stemming
    for(var i = 0; i < tokens.length; i++)
    {
        tokens[i] = Natural.PorterStemmer.stem(tokens[i]);
    }

    /////////////////////////////////
    //COMPUTING WEIGHT FOR SYMPTOMS//
    /////////////////////////////////
    var symptomsWithOccurence = [];

    for(var i = 0; i < tokens.length; i++)
    {
        var dictionaryWordAlreadyUsed = false;
        for(var j = 0; j < dictionary.length && !dictionaryWordAlreadyUsed; j++)
        {
            var tokensSymptom = tokenizer.tokenize(dictionary[j]+"");
            for(var l = 0; l < tokensSymptom.length; l++)
            {
                if(tokens[i] === tokensSymptom[l])
                {
                    //Check if symptom already here and if true, give index i
                    var k=0;
                    var symptomAlreadyUsed=false;
                    while(!symptomAlreadyUsed && k < symptomsWithOccurence.length)
                    {
                        var tokensSymptom2 = tokenizer.tokenize(symptomsWithOccurence[k].name+"");
                        for(var m = 0; m < tokensSymptom2.length; m++)
                        {
                            if(tokensSymptom2[m].name === tokens[i])
                            {
                                symptomAlreadyUsed = true;
                            }
                            else
                            {
                                k++;
                            }
                        }
                    }

                    //Increment counter or Add to array
                    if(symptomAlreadyUsed)
                    {
                        symptomsWithOccurence[k].size++;
                    }
                    else
                    {
                        symptomsWithOccurence.push({name: dictionary[j], size: 1});
                    }
                    dictionaryWordAlreadyUsed = true;
                }
            }
        }
    }

    callback(symptomsWithOccurence);
};

exports.giveSymptomsWithOccurrence=giveSymptomsWithOccurrence;